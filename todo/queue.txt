/* array queue
 * 자연수가 입력되면 큐에 저장
 * 0이 입력되면 큐에서 가장 오래 기다린 대기번호를 꺼내어 출력
 * 0보다 작은 수가 입력되면 프로그램 종료
 * 0을 입력했을 때 큐가 비었으면 "queue empty!"출력
 * 배열이 가득차서 더 넣을 수가 없을 때는 "queue full!"출력
 * 크기가 8인 배열 사용
 */
--------------------------------------------------------------------
ToDo
- 타입에 상관없이 큐에 넣고 밸 수 있도록 코드 수정한다. (void *)로 바꾸면 될 듯.
--------------------------------------------------------------------
Done
- 최종적으로 1차적으로 완료: github에 넣는다.
- 실패했던 테스트들이 모두 통과했으므로, 테스트를 추가한다.: enqueue 210, 211, 212 하고 queue full 인지 확인하는 테스트 추가 (실패하는 테스트는 아니고 성공할 것 같은 테스트들이다.)
- 아래와 같이 하면 기존 방식의 테스트들 가운데 실패하는 테스트들이 나온다. 그 테스트들이 통과할 수 있도록 메써드들을 링버퍼에 맞게  걸리는데로 바로 바로 수정하자.
- 작성해서 실패하는 모습을 보고 나면 어디를 고쳐야 할 지 보인다. 빨리 성공할 수 있도록 어느 메써드를 고쳐야 하는 지 보자: update_tail을 바꿔야 한다. 0에서 하나 채우면 1이 되지. 7에서 하나 더 채우면 8일 아니라 0이 되도록 해야 링버퍼가 되는거지.
- 자연수 8개 입력해서 queue에 넣고 4개 dequeue로 꺼낸 후 1개 입력할 때 동작해야 하는가? 어떻게?
- 아래와 같은 고민이 생길 때는 바로 그런 꽉채웠다가 몇개 뺐다가 다시 한 개 채워 넣는 상황을 테스트로 넣으면 된다. (실패하는 테스트 작성)
- ring buffer로 만들어야 dequeue 해서 공간이 생기면 다시 꽉찰때까지 enqueue 할 수 있을텐데. 어떻게 하지?
- update_tail, update_head 작성 : qLen을 넘어가면 0으로 리셋되도록.
- is_q_empty, is_q_full 함수 테스트 작성 : 현재 조건 그대로.
- 8개의 자연수 저장하기 : enqueue
- 0을 8번 입력해서 오래 기다린 대기번호를 꺼내기: dequeue
- -1입력하면 프로그램 종료
- dequeue 후 꺼내온 값이 맞는 지 확인하는 테스트 작성
- dequeue 후 head가 증가하는 지 확인하는 테스트 작성
- enque(109)후 리턴값이 -1인지 확인하는 테스트 작성
- get_q_tail 함수 구현
- get_q_data 함수 구현
- 또 1개의 자연수(102) 저장후 확인 테스트 작성 : head = 0, tail = 2, data[tail-1] = 102
- 1개의 자연수(101) 저장후 확인 테스트 작성 : head = 0, tail = 1, data[tail-1] = 101
- get_q_length 함수 구현
- init_queue 함수 구현
- github 에 소스 올리기
- 입출력하는 메인함수 구현, 직접 작동시켜보기 (유닛테스트로 할 수 있는 성격은 아닌 듯)
	* 현재 minsootest의 구조에서는 테스트를 돌리기 위한 실행파일만이 생성된다.
	* queue main()을 실행하기 위해서는 실행파일을 만들 수 있는 Makefile필요.
	* 제대로 하려면 Makefile을 작성해야 겠지만, 일단은 make queue로 build
